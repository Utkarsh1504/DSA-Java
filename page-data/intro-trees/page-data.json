{"componentChunkName":"component---src-templates-lesson-template-js","path":"/intro-trees","result":{"data":{"markdownRemark":{"html":"<p>Tree is a non-linear data structure which organises data in hierarchical form  and is recursive in nature. It is a popular data structure used in wide range of applications. Every element is considered as a node which has a predecessor and a successor. Trees are further classified into many types I.e, Binary Tree, Complete Binary Tree, Perfect Binary Tree etc.</p>\n<h2 id=\"structure-of-tree\" style=\"position:relative;\"><a href=\"#structure-of-tree\" aria-label=\"structure of tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Structure of Tree</h2>\n<p>Structure of this Data Structure is clearly mentioned by its name which is in the form of a Tree. Every circle here represents a node.  Let’s understand them better with the help of the diagram below</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/DSA-Java/static/f3b876ba1089e6aced04dc1f724d9bea/b4294/binary_tree.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3wSmP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgQf/aAAgBAQABBQJKf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAAMBAQAAAAAAAAAAAAAAAAABERAh/9oACAEBAAE/IaXHyFiLP//aAAwDAQACAAMAAAAQI8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEBAQEBAQEAAAAAAAAAAAABEQAxIUGR/9oACAEBAAE/EEQ7XnmoVlX5NV5fzEQA9ZmBCJoO/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_tree\"\n        title=\"binary_tree\"\n        src=\"/DSA-Java/static/f3b876ba1089e6aced04dc1f724d9bea/b4294/binary_tree.jpg\"\n        srcset=\"/DSA-Java/static/f3b876ba1089e6aced04dc1f724d9bea/e07e9/binary_tree.jpg 200w,\n/DSA-Java/static/f3b876ba1089e6aced04dc1f724d9bea/066f9/binary_tree.jpg 400w,\n/DSA-Java/static/f3b876ba1089e6aced04dc1f724d9bea/b4294/binary_tree.jpg 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>Root</strong> - Initial node of a tree , which divides the tree into n numbers.</p>\n<p><strong>Parent Node</strong> - The Predecessor of every node is its parent node. As D here is the parent of H &#x26; I.</p>\n<p><strong>Child Node</strong> - The successor of every node is its child node. Here, H &#x26; I are the successors of D.</p>\n<p><strong>Siblings</strong> - Nodes at the same levels are considered as siblings.</p>\n<p><strong>Leaf nodes</strong> - The nodes having no successors are the one’s which are considered as leaves.</p>\n<p><strong>Right Sub-tree</strong> - Nodes at the right side of the root node are the one’s of right sub-tree.</p>\n<p><strong>Left Sub-tree</strong> - Nodes at the left side of the root node are the one’s of left sub tree.</p>\n<h2 id=\"types-of-trees\" style=\"position:relative;\"><a href=\"#types-of-trees\" aria-label=\"types of trees permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Types of Trees</h2>\n<p>Their are in basic 4 types of Trees</p>\n<ul>\n<li>Binary tree</li>\n<li>Binary Search tree</li>\n<li>AVL tree</li>\n<li>B-tree</li>\n</ul>\n<h3 id=\"binary-tree\" style=\"position:relative;\"><a href=\"#binary-tree\" aria-label=\"binary tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Tree</h3>\n<p>Binary tree is the one whose every parent node has atmost 2 children. Number of child nodes can be either 0,1 or 2.\nBinary Trees can further be classified into more types given below in the diagram.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/d2c28/binary_type.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACc0lEQVQozx2Pa09SARyH/+egnI73Mik1RmYgHg5wbtxawmw1m7a2VrYmamGIB2HcDiogzKEwIGAgDAkV7aaW71rrstUbe9X71vfoG9Do3W979tueB3SHEYSM22Ak8Ai42iro6mHgdtcQImIFVXQOdPshxPK9DHTZB5bXW2B6v4VoUg6Yb/wFzZYdmKIX2ntQUKccYDzZRIDbCQKVdvZTGWcXU/YDWxFQdtsHVJrvpdJOSZOP/6wBW/IPGQsCoq9HgM65rvW2tyKK+QmgUjyohCdiOueW6Q/WoXnsl9snO1Uhq4QpeHrovBu0m/bzRGimjwjN9LJFr4RK81JlYBqXO6ZAm1iUDVgITL3xTKqJ2RA658LUsadXpHfZc3TeLWtqq9iSX0plloepNC8nE8+BzroIpuhVsOWAQhW2ttA59yCddXVzFaGTzroYbic4QGWcJFvyD9BZl5RKLcm5inCVKXguNQ1J49uNDq4c6KNeOCluJ3jB/KUoMryK4fqDdVybWARm2yfXJh3YjdOkyHQUx/T1CG56F8fGPuVFVMZ5kasIMtPJJjb2tYiAYTeMAwCoV60iw164TVcJthrfbMDt38dgOauC0vsQoRMO3HxWhTt/PoD5c+E/u/WrDrrqKhj2wigVt4vNP8qw0GgAaDM8KDwPLl9fmuxiSj5Q8vehTQwoEZ0dJuO2EQBAidicjEza1cMLEx3SKbaFiM6Oyvl73SPBaeD21kC58niQjNuIoZlxHCTHPKjTSyJ10o4aR1m4+TELp40GMC+FVnZ/DTtq7tqKmDsM45oMjzZrmKog1uaXUaa2AsZveaC2PS1sPYQR0TnkH4+rwUUqyvKQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_type\"\n        title=\"binary_type\"\n        src=\"/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/5a190/binary_type.png\"\n        srcset=\"/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/772e8/binary_type.png 200w,\n/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/e17e5/binary_type.png 400w,\n/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/5a190/binary_type.png 800w,\n/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/c1b63/binary_type.png 1200w,\n/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/29007/binary_type.png 1600w,\n/DSA-Java/static/377b7c41b18192122a6442f104d96a2d/d2c28/binary_type.png 4000w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"binary-search-tree\" style=\"position:relative;\"><a href=\"#binary-search-tree\" aria-label=\"binary search tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Search Tree</h3>\n<p>BST is a lot similar to a binary tree  in which every parent node has at most 2 children. Other than that, BST follows few properties which makes it different from a binary tree.</p>\n<p>The properties are -</p>\n<ul>\n<li>Value in all the nodes of a left subtree should be lesser than the value in the root node.</li>\n<li>Value in all the nodes of a right subtree should be larger than the value in the root node.</li>\n</ul>\n<p>The pictorial representation of BST is</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 283px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/DSA-Java/static/4254571961fd343f728f5099f6c96570/bde6a/binary_search_tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABJ0AAASdAHeZh94AAABuUlEQVQ4y4WUyXLCMAyG/f7v03amzLQneigHaC+0pQwkMWRhCUlIYsjyd+TiEGcBXQS2/Fm/pJihx8qyrH4XRUELrfUuY30wdTA+RpjNZnA3W9q5C70LDPwdxuMJvn5+cT6dWvt3gWVD2vl8BucWHNvWYH1QdgsmJccxkiRBFEXI87w3TgPWA7T6xTFOF5nUmCAINGg9VnnW1dUmTO0R9HA4tGLrYC1Dup1ApmnieDx2yiMo7RNYiLSVjAYkyOh9hOn0W9atebvyrmNj8DyAaa0hhGhLVn9SIbBarWAsDZlpX1ejKMR8Podl8VZZWDPYtm1sNhvcahaZZVnwD34rTsuQZNLcpWkqfZ9kKg3Vm3yWZVocq98ahqH0FHSrKTSTauhJvgZUMM/zqqwUnDrZhLqu+/9YXIxm0/ev0lmWZ7JmnPNqaMl2u60cDyGuRff3eywWi2pNyae1IAz/gZTV58cEJl9X6RPYMAwMh29wXA9lWSDLC/DlDIOXV7ieVwH9/Q5Pjw/y8UiTBIwOU4YW59pMkWTZyZockkdKVCnI6IzjOLDXa1kKpgqt6lJvUtdj0PyWVVx5eSv/ABHFgY5IsAY2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_search_tree\"\n        title=\"binary_search_tree\"\n        src=\"/DSA-Java/static/4254571961fd343f728f5099f6c96570/bde6a/binary_search_tree.png\"\n        srcset=\"/DSA-Java/static/4254571961fd343f728f5099f6c96570/772e8/binary_search_tree.png 200w,\n/DSA-Java/static/4254571961fd343f728f5099f6c96570/bde6a/binary_search_tree.png 283w\"\n        sizes=\"(max-width: 283px) 100vw, 283px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"avl-tree\" style=\"position:relative;\"><a href=\"#avl-tree\" aria-label=\"avl tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AVL Tree</h3>\n<p>AVL trees are considered as the variants of binary tree which have the characteristics of both Binary tree and Binary search tree. These trees are self-balanced which means the height of left sub tree and right are sub tree are equal. This balanced is measured in terms of balancing factor.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 262px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/DSA-Java/static/0a38b7c7df2074c2748fa4bb0c2a9d45/8ff13/AVL.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAADa0lEQVQ4y22SWUxcZRiGn3MghEVgaGpLAlSsphbbRNKC2hgJVGqrYVga0sEStopAGHbHgQHODHBmhVlgNoYyzOBAS1kKIViN0Qsu1KvGGK+MponWu8ZGrrzQNMfM2Likfsl38ef987zf//0viDCgH0CSJYYMQ2j7e8WWlk6uaNoylpdX7vq9C11jRokPb6yK+Xn5SGZJaGxrpOndJq62XuWJUjeoqVRXomnVUNNQw/mqCl46WcLzz50sDIej3+onR61A6pp7UxQRaetuI+1QWqKTnkp6Etja20ppeSlqjZqSspL0sktlR4EjQI6iKNCAKqUw5WkgD8iua6rLBYSE9n8VF/b395MPHh4QWgyFIsuRP8inIKH9ogiP74h7H+/Rr+uvj63GFIvZUiHLMvML8+KUbSrJ7DAL/pAft88NrjmX0KfrY2d3B71B3+xwOry8wGGbQWZ9eUOIzS/hnLEnjKuqqkq9i975s/Vn3wQy4mZWpxXHtAOD3yAMe4dh/fY6dpf9lG5Y1wCIn9y5wzuXr7w+Oz1T/c1PX+N02Y47Z2z1IkJBHHpv+x5IpKaQkgMUWJ3Wy7JZfnY4OMzQ7JDA1uYWgVBgK7QYUiq1lTmOGRsLwWA4srQYX1JKNBqeunXrplLeeu7E+eJX2XPvJis9Cpk5mVyovVAQX4Ez4PTEzR58/iCZzY0NzpScOaUz68rpRdUhtWHVmfL6J7SX0JAWcy0evtbZrAYy10ZWiXoi4oq8QiAYiL84W9ujVRdfLH4tDjRYRuB6KBSyTVqaHV47v370UOgytguyJGGzyuwHPxMGe7Qcz87N8ro9t4Mu7ytO9zQ1ddU5s3OzNzrf62zUj3wQB6tsFuuGyz5TSywavT8bcoWVuwo/b/8oKoMKRoNBsMqTYq+2Q5D0evq6Ooqi4aXfja6xwWV/hG5t9zNen1cZt42bxoZGaWlpOhoMBA4m7KY5jpCURhlZrCJyHZj4p5XvFO5//wO7Czc5RnoGGjI7ytsTEwGFpHM6nkm7x0Li16tR8Ubxy/AW8AWw/hj2r4wqjx7xaWwncTZ6JCaMpna/z/fb6WNFh3xzvrV5f+DLv0N+EXi/q0co6zn3FzDyX2BDbS25KhVkwZRkSgp6AoyOGNQ2h/WrrGuZJzwOt0myj29TQSpvw4sDRcKfdGRWIN+P7jsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AVL\"\n        title=\"AVL\"\n        src=\"/DSA-Java/static/0a38b7c7df2074c2748fa4bb0c2a9d45/8ff13/AVL.png\"\n        srcset=\"/DSA-Java/static/0a38b7c7df2074c2748fa4bb0c2a9d45/772e8/AVL.png 200w,\n/DSA-Java/static/0a38b7c7df2074c2748fa4bb0c2a9d45/8ff13/AVL.png 262w\"\n        sizes=\"(max-width: 262px) 100vw, 262px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Now, let’s understand what is a balancing factor -</p>\n<ul>\n<li>It is the difference between the left sub tree and right sub tree.</li>\n<li>The value of balancing factor must be 0 , -1 and 1 , which means each node will be having a balancing factor of 0,1 and -1.</li>\n<li>Values of nodes other than -1, to 1 in an AVL tree will represent an unbalanced tree that needs to be balanced.</li>\n<li>If a node has a balance factor of 1, it means that the left subtree is one level higher than the right subtree.</li>\n<li>If a node has a balance factor of 0, it means that the height of the left subtree and the right subtree is equal.</li>\n<li>If a node has a balance factor of -1, it means that the right subtree is one level higher than the left subtree or the left subtree is one level lower than the right subtree.</li>\n</ul>\n<h3 id=\"b-tree\" style=\"position:relative;\"><a href=\"#b-tree\" aria-label=\"b tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>B-Tree</h3>\n<p>It is also known as height-balanced m way tree, where m is the order of the tree. B-tree is more generalised form of a binary search tree.  In the case of a binary tree, the leaf nodes might not be at the same level. However, in the case of a B Tree, all the leaf nodes should be at the same level. </p>\n<p>Properties of B-Tree are -</p>\n<ul>\n<li>The root may have between 2 and m children.</li>\n<li>All other nodes must have between [M/2] and m children.</li>\n<li>A node that has k children will have k-1 key values.</li>\n<li>Thus, the root may have only 2 children; all other nodes must be at least half full .</li>\n</ul>\n<h2 id=\"traversals-in-trees\" style=\"position:relative;\"><a href=\"#traversals-in-trees\" aria-label=\"traversals in trees permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Traversals in Trees</h2>\n<p>Tree traversals means traversing or visiting each node of the tree. Other than tree data structure, Stack , Queue and Linked List only have one way for traversing which makes Trees different from them also.</p>\n<p>Traversals are of 3 types</p>\n<ol>\n<li><strong>In-order Traversal</strong> - This traversal calls for the sequence of LEFT, ROOT, RIGHT.</li>\n<li><strong>Pre-order Traversal</strong> - This traversal calls for the sequence of ROOT ,LEFT, RIGHT.</li>\n<li><strong>Post-order Traversal</strong> - This traversal calls for the sequence of LEFT, RIGHT, ROOT.</li>\n</ol>\n<p>Now let’s understand these a help of an example</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 417px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/DSA-Java/static/7cb45ef98b0253f12be01907ba622365/f27fb/traversal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABBUlEQVQoz32R246DIBRF/f/Ps9E3qyhYROEAJrXWc2QyJaFONLOfIKzF5pKFU/Z9DyG8Xq9hGABg/yRcJTubEXXO3e/3tm3XdT1u+p8cQiCiaZqklMuyWGu7rjPGXJZ/ZfyEc84Ym+c5VRGRMaZtWyEEESHihTzPs5SSMbYsy/mQ67pWVSWEsNb+kSOntRZCOOfOZgLqupZSfuW4EGsRse97ADj6ceC97/ueiJRSCci2bdNaF0WRuLIsx3FExDh9v98AkOd5uu3tdlNKIWIGAFrrY5v3nnNurUVEIgKApmmcc+ks3nvGGOf8V7bWxs9MVUopYwwRRdQYE18x5vl8Ph6PaZp+AA9oQ9D4BbM2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"traversal\"\n        title=\"traversal\"\n        src=\"/DSA-Java/static/7cb45ef98b0253f12be01907ba622365/f27fb/traversal.png\"\n        srcset=\"/DSA-Java/static/7cb45ef98b0253f12be01907ba622365/772e8/traversal.png 200w,\n/DSA-Java/static/7cb45ef98b0253f12be01907ba622365/e17e5/traversal.png 400w,\n/DSA-Java/static/7cb45ef98b0253f12be01907ba622365/f27fb/traversal.png 417w\"\n        sizes=\"(max-width: 417px) 100vw, 417px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Taking the above tree into consideration let's understand how  traversing is done</p>\n<p><strong>In-order Traversal (LEFT , ROOT, RIGHT)</strong> - Traverse the left sub-tree , visit the root , traverse the right sub-tree which makes the sequence (1,5,6,10,17,19,21)</p>\n<p><strong>Pre-order traversal (ROOT, LEFT , RIGHT)</strong> - Visit the root , Traverse the left sub tree , Traverse the right sub tree which makes the sequence (10,5,1,6,19,17,21)</p>\n<p><strong>Post-order traversal (LEFT,RIGHT,ROOT)</strong> - Traverse the left sub tree , Traverse the right sub-tree , visit the root which makes the sequence (1,6,5,17,21,19,10)</p>","frontmatter":{"path":"/intro-trees","title":"Intro to Trees","order":"14A","section":"Trees"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"4B","path":"/arraylist","title":"ArrayList In Java"}}},{"node":{"frontmatter":{"order":"24A","path":"/assignment","title":"Assignments"}}},{"node":{"frontmatter":{"order":"4A","path":"/arrays","title":"Introduction to Arrays"}}},{"node":{"frontmatter":{"order":"9E","path":"/backtrack-maze","title":"Maze Problems"}}},{"node":{"frontmatter":{"order":"9D","path":"/backtrack-nknight","title":"N Knights"}}},{"node":{"frontmatter":{"order":"9B","path":"/backtrack-sudoku","title":"Sudoku Solver"}}},{"node":{"frontmatter":{"order":"9A","path":"/backtracking","title":"Introduction to Backtracking"}}},{"node":{"frontmatter":{"order":"5B","path":"/binarysearch","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10B","path":"/bitwise-operator","title":"Complete Bitwise Operators"}}},{"node":{"frontmatter":{"order":"4D","path":"/bmmv-algorithm","title":"Boyer-Moore Majority Voting Algorithm"}}},{"node":{"frontmatter":{"order":"9C","path":"/backtrack-nqueen","title":"N Queens"}}},{"node":{"frontmatter":{"order":"5C","path":"/bubblesort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"5F","path":"/countsort","title":"Count Sort"}}},{"node":{"frontmatter":{"order":"5H","path":"/cyclesort","title":"Cyclic Sort"}}},{"node":{"frontmatter":{"order":"3A","path":"/dataTypes","title":"Learn Data Types"}}},{"node":{"frontmatter":{"order":"2C","path":"/firstjavaprogram","title":"First Java Program"}}},{"node":{"frontmatter":{"order":"8B","path":"/flow-of-recursion","title":"Flow of Recursion"}}},{"node":{"frontmatter":{"order":"2A","path":"/flowchart","title":"Flowchart & Pseudocode"}}},{"node":{"frontmatter":{"order":"3F","path":"/functions","title":"Function & Scope"}}},{"node":{"frontmatter":{"order":"20A","path":"/greedy","title":"Introduction to Greedy Algorithms"}}},{"node":{"frontmatter":{"order":"5E","path":"/insertion","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"15A","path":"/intro-binarytree","title":"Intro to Binary Tree"}}},{"node":{"frontmatter":{"order":"16A","path":"/intro-bst","title":"Intro to BST"}}},{"node":{"frontmatter":{"order":"7A","path":"/intro-complexity","title":"Complexity Analysis"}}},{"node":{"frontmatter":{"order":"19A","path":"/intro-dp","title":"Introduction to DP"}}},{"node":{"frontmatter":{"order":"12A","path":"/intro-ds","title":"Introduction to Data Structures"}}},{"node":{"frontmatter":{"order":"22A","path":"/intro-graphs","title":"Introduction to Graphs"}}},{"node":{"frontmatter":{"order":"18A","path":"/intro-hashmap","title":"Introduction to Hashmap"}}},{"node":{"frontmatter":{"order":"17A","path":"/intro-heap","title":"Introduction to Heaps"}}},{"node":{"frontmatter":{"order":"12B","path":"/intro-linkedlist","title":"Introduction to Linked List"}}},{"node":{"frontmatter":{"order":"10A","path":"/intro-maths","title":"Introduction to Maths in DSA"}}},{"node":{"frontmatter":{"order":"11A","path":"/intro-oop","title":"Introduction"}}},{"node":{"frontmatter":{"order":"21A","path":"/intro-priorityqueues","title":"Introduction to Priority Queues"}}},{"node":{"frontmatter":{"order":"1B","path":"/intro-programming","title":"Intro to Programming"}}},{"node":{"frontmatter":{"order":"8A","path":"/intro-recursion","title":"Intro to Recursion"}}},{"node":{"frontmatter":{"order":"13A","path":"/intro-stacks","title":"Intro to Stack"}}},{"node":{"frontmatter":{"order":"6A","path":"/intro-string","title":"Intro to Strings"}}},{"node":{"frontmatter":{"order":"14A","path":"/intro-trees","title":"Intro to Trees"}}},{"node":{"frontmatter":{"order":"23A","path":"/intro-tries","title":"Introduction to Tries"}}},{"node":{"frontmatter":{"order":"1A","path":"/introduction","title":"Welcome"}}},{"node":{"frontmatter":{"order":"3C","path":"/io-conditionals","title":"Input/Output & Conditionals"}}},{"node":{"frontmatter":{"order":"4F","path":"/jagged-array","title":"Jagged Arrays"}}},{"node":{"frontmatter":{"order":"2B","path":"/java-setup","title":"Java Development Setup"}}},{"node":{"frontmatter":{"order":"3E","path":"/jumps","title":"Jumps Statements"}}},{"node":{"frontmatter":{"order":"5A","path":"/linearsearch","title":"Linear Search"}}},{"node":{"frontmatter":{"order":"3D","path":"/loops","title":"Loops In Java"}}},{"node":{"frontmatter":{"order":"8E","path":"/mergesort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"10C","path":"/num-one","title":"Number Theory Part-A"}}},{"node":{"frontmatter":{"order":"10E","path":"/num-three","title":"Number Theory Part-C"}}},{"node":{"frontmatter":{"order":"10D","path":"/num-two","title":"Number Theory Part-B"}}},{"node":{"frontmatter":{"order":"3B","path":"/operators","title":"Operators in Java"}}},{"node":{"frontmatter":{"order":"5I","path":"/practise-question","title":"Practise Questions"}}},{"node":{"frontmatter":{"order":"4C","path":"/print-patterns","title":"Printing Patterns"}}},{"node":{"frontmatter":{"order":"11C","path":"/properties","title":"Properties of OOP"}}},{"node":{"frontmatter":{"order":"8F","path":"/quicksort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5G","path":"/radixsort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"7D","path":"/recurrence","title":"Recurrence Relations"}}},{"node":{"frontmatter":{"order":"8C","path":"/recursion-arrays","title":"Recursion & Array"}}},{"node":{"frontmatter":{"order":"8G","path":"/recursion-practise","title":"Standard Practise Questions"}}},{"node":{"frontmatter":{"order":"8D","path":"/recursion-string","title":"Recursion & Strings"}}},{"node":{"frontmatter":{"order":"5D","path":"/selectionsort","title":"Selection Sort"}}},{"node":{"frontmatter":{"order":"7C","path":"/space-complexity","title":"Space Complexity"}}},{"node":{"frontmatter":{"order":"6B","path":"/string-builder","title":"StringBuilder in Java"}}},{"node":{"frontmatter":{"order":"4E","path":"/subarrays","title":"Subarrays"}}},{"node":{"frontmatter":{"order":"11B","path":"/this-constructor","title":"this Keyword & Constructor"}}},{"node":{"frontmatter":{"order":"7B","path":"/time-complexity","title":"Time Complexity"}}},{"node":{"frontmatter":{"order":"7E","path":"/time_space_tradeoff","title":"Time Space Tradeoff"}}}]}},"pageContext":{}},"staticQueryHashes":["137611351"]}