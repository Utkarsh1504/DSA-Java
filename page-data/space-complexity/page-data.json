{"componentChunkName":"component---src-templates-lesson-template-js","path":"/space-complexity","result":{"data":{"markdownRemark":{"html":"<p>Now that we have learned about the 'time' aspect of performance analysis of an algorithm, let's move on to memory aspect of the same.</p>\n<p><em><strong>Space complexity of an algorithm is basically the amount of memory it needs to run to completion, ie, to execute and produce the result.</strong></em></p>\n<p>Calculation of space complexity used to hold much more significance in early days of computing than it does now. This is because most machines today have large memories and the user does not need to worry about running out of memory for running a program or two. But it is a crucial estimate where the physical memory is limited or closely monitored.</p>\n<p><em>Above all, it’s necessary to mention that space complexity depends on a variety of things such as the programming language, the compiler, or even the machine running the algorithm.</em></p>\n<h2 id=\"memory-usage-while-execution\" style=\"position:relative;\"><a href=\"#memory-usage-while-execution\" aria-label=\"memory usage while execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory Usage while Execution</h2>\n<p>While executing, an algorithm uses memory space for three reasons:</p>\n<ul>\n<li><strong>Instruction Space</strong></li>\n</ul>\n<p>-- It's the amount of memory used to save the compiled version of instructions.</p>\n<ul>\n<li><strong>Environmental Stack</strong></li>\n</ul>\n<p>-- Sometimes an algorithm(function) may be called inside another algorithm(function). In such a situation, the current variables are pushed onto the system stack, where they wait for further execution and then the call to the inside algorithm(function) is made.<br>\nEx.  If a function A() calls function B() inside it, then all the variables of the function A() will get stored on the system stack temporarily, while the function B() is called and executed inside the function A().</p>\n<ul>\n<li><strong>Data Space</strong></li>\n</ul>\n<p>-- Amount of space used by the variables and constants.</p>\n<p>So in general for any algorithm, the memory may be used for the following: - <code class=\"language-text\">Variables (Data Space)</code>, <code class=\"language-text\">Program Instruction (Instruction Space)</code> and  <code class=\"language-text\">Execution (Environmental Space)</code>.\nBut while calculating the Space Complexity of any algorithm, we usually consider only Data Space and we neglect the Instruction Space and Environmental Stack.</p>\n<h2 id=\"calculation-of-space-complexity\" style=\"position:relative;\"><a href=\"#calculation-of-space-complexity\" aria-label=\"calculation of space complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Calculation of Space Complexity</h2>\n<p>An algorithm's space can be categorized into 2 parts:<br>\n<strong>1) Fixed Part</strong> - It is independent of the characteristics of input and output.<br>\nIt includes instruction(code) space, space for simple variables, fixed-size component variables and constants.<br>\n<strong>2) Variable Part</strong> - It depends on instance characteristics.<br>\nIt consists of the space needed by component variables whose size is dependent on the particular problem instance being solved, the space needed by referenced variables, and the recursion stack space.</p>\n<p>Sometimes, <em><strong>Auxiliary Space</strong></em> is confused with Space Complexity. The Auxiliary Space is the extra space or the temporary space used by the algorithm during it's execution.</p>\n<p><code class=\"language-text\">Space Complexity = Auxiliary Space + Input space</code></p>\n<blockquote>\n<p>Thus, space requirement S(M) of any algorithm M is:\nS(M) = c + Sm (Instance characteristics), where c is constant</p>\n</blockquote>\n<p>While analyzing space complexity, we primarily concentrate on estimating Sm.\nConsider the following algorithm:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In this particular method, three variables are used and allocated in memory:</p>\n<ol>\n<li>The first <code class=\"language-text\">int</code> argument, a</li>\n<li>The second <code class=\"language-text\">int</code> argument, b</li>\n<li>The returned sum result which is also an <code class=\"language-text\">int</code> like a and b</li>\n</ol>\n<p>In Java, a single integer variable occupies <code class=\"language-text\">4</code> bytes of memory. In this example, we have three integer variables. Therefore, this algorithm always takes 12 bytes of memory to complete (3*4 bytes).</p>\n<blockquote>\n<p>We can clearly see that the space complexity is constant, so, it can be expressed in big-O notation as O(1).</p>\n</blockquote>\n<p>Now let us see another example -</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">sumArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sum <span class=\"token operator\">+=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Again, let’s list all variables present in the above code:</p>\n<ol>\n<li>Array – the function’s only argument – the space taken by the array is equal to 4n bytes where n is the length of the array</li>\n<li>The <code class=\"language-text\">int</code> variable, size</li>\n<li>The <code class=\"language-text\">int</code> variable, sum</li>\n<li>The <code class=\"language-text\">int</code> iterator, i</li>\n</ol>\n<p>The total space needed for this algorithm to complete is 4n + 4 + 4 + 4 (bytes). The highest order is of n in this equation. Thus, the space complexity of that code snippet is O(n).\nWhen the program consists of loops (In case of Iterative algorithms), it will have linear space complexity or O(n).</p>\n<blockquote>\n<p>While dealing with operations on data structures, we can say that space complexity depends on size of the data structure. Ex, if an array stores N elements, its space complexity is O(N). A program with an array of N arrays will have space complexity O(N^2) and so on.</p>\n</blockquote>\n<p>Now, the space complexity analysis also takes into account the size of recursion stack in case of recursive algorithms.\nConsider the code below -</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Algorithm</span> <span class=\"token function\">fact</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span>  \n    <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In this case there are 3 statements ( an <code class=\"language-text\">if</code> statement &#x26; 2<code class=\"language-text\">return</code> statements). The depth of recursion is <em>n + 1</em>. Thus the recursion stack space needed is >=3(n+1). So we can say, space complexity is O(n) i.e. linear.</p>\n<h2 id=\"space-complexities-of-common-algorithms\" style=\"position:relative;\"><a href=\"#space-complexities-of-common-algorithms\" aria-label=\"space complexities of common algorithms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Space Complexities of Common Algorithms</h2>\n<p>The space complexities of various algorithms is given below -</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Space Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Linear Search</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Binary Search</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Bubble Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Insertion Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Selection Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Heapsort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Shell Sort</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Quicksort</td>\n<td>O(log(n))</td>\n</tr>\n<tr>\n<td>Mergesort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Timsort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Tree Sort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Bucket Sort</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Radix Sort</td>\n<td>O(n+k)</td>\n</tr>\n<tr>\n<td>Counting Sort</td>\n<td>O(k)</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"path":"/space-complexity","title":"Space Complexity","order":"7C","section":"Space & Time Complexity"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"4B","path":"/arraylist","title":"ArrayList In Java"}}},{"node":{"frontmatter":{"order":"24A","path":"/assignment","title":"Assignments"}}},{"node":{"frontmatter":{"order":"4A","path":"/arrays","title":"Introduction to Arrays"}}},{"node":{"frontmatter":{"order":"9E","path":"/backtrack-maze","title":"Maze Problems"}}},{"node":{"frontmatter":{"order":"9D","path":"/backtrack-nknight","title":"N Knights"}}},{"node":{"frontmatter":{"order":"9B","path":"/backtrack-sudoku","title":"Sudoku Solver"}}},{"node":{"frontmatter":{"order":"9A","path":"/backtracking","title":"Introduction to Backtracking"}}},{"node":{"frontmatter":{"order":"5B","path":"/binarysearch","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10B","path":"/bitwise-operator","title":"Complete Bitwise Operators"}}},{"node":{"frontmatter":{"order":"4D","path":"/bmmv-algorithm","title":"Boyer-Moore Majority Voting Algorithm"}}},{"node":{"frontmatter":{"order":"9C","path":"/backtrack-nqueen","title":"N Queens"}}},{"node":{"frontmatter":{"order":"5C","path":"/bubblesort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"5F","path":"/countsort","title":"Count Sort"}}},{"node":{"frontmatter":{"order":"5H","path":"/cyclesort","title":"Cyclic Sort"}}},{"node":{"frontmatter":{"order":"3A","path":"/dataTypes","title":"Learn Data Types"}}},{"node":{"frontmatter":{"order":"2C","path":"/firstjavaprogram","title":"First Java Program"}}},{"node":{"frontmatter":{"order":"8B","path":"/flow-of-recursion","title":"Flow of Recursion"}}},{"node":{"frontmatter":{"order":"2A","path":"/flowchart","title":"Flowchart & Pseudocode"}}},{"node":{"frontmatter":{"order":"3F","path":"/functions","title":"Function & Scope"}}},{"node":{"frontmatter":{"order":"20A","path":"/greedy","title":"Introduction to Greedy Algorithms"}}},{"node":{"frontmatter":{"order":"5E","path":"/insertion","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"15A","path":"/intro-binarytree","title":"Intro to Binary Tree"}}},{"node":{"frontmatter":{"order":"16A","path":"/intro-bst","title":"Intro to BST"}}},{"node":{"frontmatter":{"order":"7A","path":"/intro-complexity","title":"Complexity Analysis"}}},{"node":{"frontmatter":{"order":"19A","path":"/intro-dp","title":"Introduction to DP"}}},{"node":{"frontmatter":{"order":"12A","path":"/intro-ds","title":"Introduction to Data Structures"}}},{"node":{"frontmatter":{"order":"22A","path":"/intro-graphs","title":"Introduction to Graphs"}}},{"node":{"frontmatter":{"order":"18A","path":"/intro-hashmap","title":"Introduction to Hashmap"}}},{"node":{"frontmatter":{"order":"17A","path":"/intro-heap","title":"Introduction to Heaps"}}},{"node":{"frontmatter":{"order":"12B","path":"/intro-linkedlist","title":"Introduction to Linked List"}}},{"node":{"frontmatter":{"order":"10A","path":"/intro-maths","title":"Introduction to Maths in DSA"}}},{"node":{"frontmatter":{"order":"11A","path":"/intro-oop","title":"Introduction"}}},{"node":{"frontmatter":{"order":"21A","path":"/intro-priorityqueues","title":"Introduction to Priority Queues"}}},{"node":{"frontmatter":{"order":"1B","path":"/intro-programming","title":"Intro to Programming"}}},{"node":{"frontmatter":{"order":"8A","path":"/intro-recursion","title":"Intro to Recursion"}}},{"node":{"frontmatter":{"order":"13A","path":"/intro-stacks","title":"Intro to Stack"}}},{"node":{"frontmatter":{"order":"6A","path":"/intro-string","title":"Intro to Strings"}}},{"node":{"frontmatter":{"order":"14A","path":"/intro-trees","title":"Intro to Trees"}}},{"node":{"frontmatter":{"order":"23A","path":"/intro-tries","title":"Introduction to Tries"}}},{"node":{"frontmatter":{"order":"1A","path":"/introduction","title":"Welcome"}}},{"node":{"frontmatter":{"order":"3C","path":"/io-conditionals","title":"Input/Output & Conditionals"}}},{"node":{"frontmatter":{"order":"4F","path":"/jagged-array","title":"Jagged Arrays"}}},{"node":{"frontmatter":{"order":"2B","path":"/java-setup","title":"Java Development Setup"}}},{"node":{"frontmatter":{"order":"3E","path":"/jumps","title":"Jumps Statements"}}},{"node":{"frontmatter":{"order":"5A","path":"/linearsearch","title":"Linear Search"}}},{"node":{"frontmatter":{"order":"3D","path":"/loops","title":"Loops In Java"}}},{"node":{"frontmatter":{"order":"8E","path":"/mergesort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"10C","path":"/num-one","title":"Number Theory Part-A"}}},{"node":{"frontmatter":{"order":"10E","path":"/num-three","title":"Number Theory Part-C"}}},{"node":{"frontmatter":{"order":"10D","path":"/num-two","title":"Number Theory Part-B"}}},{"node":{"frontmatter":{"order":"3B","path":"/operators","title":"Operators in Java"}}},{"node":{"frontmatter":{"order":"5I","path":"/practise-question","title":"Practise Questions"}}},{"node":{"frontmatter":{"order":"4C","path":"/print-patterns","title":"Printing Patterns"}}},{"node":{"frontmatter":{"order":"11C","path":"/properties","title":"Properties of OOP"}}},{"node":{"frontmatter":{"order":"8F","path":"/quicksort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5G","path":"/radixsort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"7D","path":"/recurrence","title":"Recurrence Relations"}}},{"node":{"frontmatter":{"order":"8C","path":"/recursion-arrays","title":"Recursion & Array"}}},{"node":{"frontmatter":{"order":"8G","path":"/recursion-practise","title":"Standard Practise Questions"}}},{"node":{"frontmatter":{"order":"8D","path":"/recursion-string","title":"Recursion & Strings"}}},{"node":{"frontmatter":{"order":"5D","path":"/selectionsort","title":"Selection Sort"}}},{"node":{"frontmatter":{"order":"7C","path":"/space-complexity","title":"Space Complexity"}}},{"node":{"frontmatter":{"order":"6B","path":"/string-builder","title":"StringBuilder in Java"}}},{"node":{"frontmatter":{"order":"4E","path":"/subarrays","title":"Subarrays"}}},{"node":{"frontmatter":{"order":"11B","path":"/this-constructor","title":"this Keyword & Constructor"}}},{"node":{"frontmatter":{"order":"7B","path":"/time-complexity","title":"Time Complexity"}}},{"node":{"frontmatter":{"order":"7E","path":"/time_space_tradeoff","title":"Time Space Tradeoff"}}}]}},"pageContext":{}},"staticQueryHashes":["137611351"]}